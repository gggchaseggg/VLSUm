<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Лабораторная работа 8 - Вариант 6</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <style>
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #222;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas3D" width="800" height="600"></canvas>
    <script>
      // Инициализация WebGL
      const canvas = document.getElementById("canvas3D");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        alert("Ваш браузер не поддерживает WebGL");
      }

      // Шейдеры
      const vertexShaderSource = `
            attribute vec3 aVertexPosition;
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            void main(void) {
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            }
        `;

      const fragmentShaderSource = `
            precision mediump float;
            void main(void) {
                gl_FragColor = vec4(1.0, 0.8, 0.2, 1.0); // Цвет: жёлто-оранжевый
            }
        `;

      // Функция для компиляции шейдера
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "Ошибка компиляции шейдера:",
            gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // Создание шейдерной программы
      const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(
        fragmentShaderSource,
        gl.FRAGMENT_SHADER
      );

      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.error(
          "Ошибка связывания шейдерной программы:",
          gl.getProgramInfoLog(shaderProgram)
        );
      }

      gl.useProgram(shaderProgram);

      // Локации атрибутов и uniform-переменных
      const vertexPositionAttribute = gl.getAttribLocation(
        shaderProgram,
        "aVertexPosition"
      );
      const mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
      const pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");

      // Буферы
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

      const vertices = [
        // Лицевая грань
        -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0.5,
        // Задняя грань
        -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5,
      ];
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW
      );

      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

      const indices = [
        0,
        1,
        2,
        2,
        3,
        0, // Лицевая грань
        4,
        5,
        6,
        6,
        7,
        4, // Задняя грань
        0,
        1,
        5,
        5,
        4,
        0, // Нижняя грань
        3,
        2,
        6,
        6,
        7,
        3, // Верхняя грань
        0,
        3,
        7,
        7,
        4,
        0, // Левая грань
        1,
        2,
        6,
        6,
        5,
        1, // Правая грань
      ];
      gl.bufferData(
        gl.ELEMENT_ARRAY_BUFFER,
        new Uint16Array(indices),
        gl.STATIC_DRAW
      );

      // Матрицы
      const mvMatrix = mat4.create();
      const pMatrix = mat4.create();

      function setMatrixUniforms() {
        gl.uniformMatrix4fv(mvMatrixUniform, false, mvMatrix);
        gl.uniformMatrix4fv(pMatrixUniform, false, pMatrix);
      }

      // Отрисовка
      function drawScene() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(
          pMatrix,
          Math.PI / 4,
          canvas.width / canvas.height,
          0.1,
          100.0
        );
        mat4.identity(mvMatrix);

        mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -4.0]);
        mat4.scale(mvMatrix, mvMatrix, [1.5, 1.5, 1.5]);
        mat4.rotateY(mvMatrix, mvMatrix, Math.PI / 4);

        setMatrixUniforms();

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(
          vertexPositionAttribute,
          3,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.enableVertexAttribArray(vertexPositionAttribute);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
      }

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      drawScene();
    </script>
  </body>
</html>
