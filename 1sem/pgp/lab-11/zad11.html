<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <title>Лабораторная работа 11</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="canvas3D" width="800" height="600"></canvas>
<script>

    const torusVertices = [];
    const torusIndices = [];
    const torusNormals = [];

    const radius = 1.0; // Радиус торуса
    const tube = 0.4; // Радиус трубы торуса
    const radialSegments = 32; // Количество сегментов по окружности торуса
    const tubularSegments = 16; // Количество сегментов по окружности трубы

    for (let j = 0; j <= radialSegments; j++) {
        const theta = (j / radialSegments) * Math.PI * 2;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);

        for (let i = 0; i <= tubularSegments; i++) {
            const phi = (i / tubularSegments) * Math.PI * 2;
            const cosPhi = Math.cos(phi);
            const sinPhi = Math.sin(phi);

            const x = (radius + tube * cosPhi) * cosTheta;
            const y = (radius + tube * cosPhi) * sinTheta;
            const z = tube * sinPhi;

            torusVertices.push(x, y, z);

            const nx = cosPhi * cosTheta;
            const ny = cosPhi * sinTheta;
            const nz = sinPhi;
            torusNormals.push(nx, ny, nz);
        }
    }

    for (let j = 0; j < radialSegments; j++) {
        for (let i = 0; i < tubularSegments; i++) {
            const a = (j * (tubularSegments + 1)) + i;
            const b = a + tubularSegments + 1;

            torusIndices.push(a, b, a + 1);
            torusIndices.push(b, b + 1, a + 1);
        }
    }

    const vertexShaderSource = `
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    varying vec3 vNormal;
    varying vec4 vVertex;

    void main(void) {

        vNormal = normalize(uNMatrix * aVertexNormal);
        vVertex = uMVMatrix * vec4(aVertexPosition, 1.0);

        gl_Position = uPMatrix * vVertex;
    }
`;

    const fragmentShaderSource = `
    precision mediump float;

    uniform vec3 uColor;

    varying vec4 vVertex;
    varying vec3 vNormal;
    varying vec4 vFinalColor;

    uniform mat4 uLightMatrix;
    uniform vec3 uPointLightLocation;

    const float shiness = 30.0;

    const vec3 ambientLightColor = vec3(0.1, 0.1, 0.1);

    void main(void) {
        vec4 lightLocation = uLightMatrix * vec4(uPointLightLocation, 1.0);
        vec3 lightDirection = lightLocation.xyz - vVertex.xyz;

        vec3 N = normalize(vNormal);
        vec3 L = normalize(lightDirection);
        float lambertComponent = max(dot(N, -L), 0.0);
        vec3 diffuseLight = uColor * lambertComponent;


        vec3 eyeVec = -vec3(vVertex.xyz);
        vec3 R = normalize(eyeVec);
        vec3 halfwayVector = normalize(-L + R);

        float specular = pow(max(dot(halfwayVector, N), 0.0), shiness);
        vec3 specularLight = uColor * specular;


        vec3 sumColor = ambientLightColor + diffuseLight + specularLight;

        gl_FragColor = vec4(sumColor, 1.0);
    }
`;

    // Инициализация WebGL
    const initGL = (canvas) => {
        try {
            const gl = canvas.getContext('webgl');
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
            return gl;
        } catch (e) {
            console.error('Ошибка инициализации WebGL', e);
            return null;
        }
    };

    // Создание шейдера
    const createShader = (gl, source, type) => {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    };

    // Компиляция шейдеров
    const initShaders = (gl) => {
        const vertexShader = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, 'aVertexNormal');
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
        shaderProgram.lightDirectionUniform = gl.getUniformLocation(shaderProgram, 'uLightDirection');

        return shaderProgram;
    };

    // Создание буферов
    const initBuffers = (gl, vertices, indices, normals) => {
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        return {vertexBuffer, indexBuffer, normalBuffer};
    };

    // Рендеринг тора
    const drawScene = (gl, shaderProgram, buffers, pMatrix, mvMatrix) => {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertexBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normalBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indexBuffer);

        const lightDirection = [0.5, 0.7, 1.0]; // Направление света
        gl.uniform3fv(shaderProgram.lightDirectionUniform, lightDirection);

        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

        gl.drawElements(gl.TRIANGLES, buffers.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    };

    // Основная функция
    const webGLStart = () => {
        const canvas = document.getElementById('canvas3D');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const gl = initGL(canvas);
        const shaderProgram = initShaders(gl);

        const buffers = initBuffers(gl, torusVertices, torusIndices, torusNormals);
        buffers.indexBuffer.numItems = torusIndices.length;

        const pMatrix = mat4.create();
        const mvMatrix = mat4.create();
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        mat4.perspective(pMatrix, Math.PI / 4, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
        mat4.identity(mvMatrix);
        mat4.translate(mvMatrix, mvMatrix, [0, 0, -5]);
        mat4.rotate(mvMatrix, mvMatrix, Math.PI / 6, [1, 0, 0]);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        drawScene(gl, shaderProgram, buffers, pMatrix, mvMatrix);
    };

    webGLStart();

</script>
</body>
</html>
